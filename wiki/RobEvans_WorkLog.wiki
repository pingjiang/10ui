#summary Rob Evans' Work Log
==Work log==
This is the work log of Rob Evans, that is all.
===Wed 10/24/07===
   * Continuing investigation of multiple HOVER_INs and HOVER_OUTs
      * Implemented an ltoa function (opposite of atol) to display rectangle IDs
      * Found that multiple INs and OUTs were correct, simply entering three rectangles simultaneously for a split second before leaving them because there's a table event at a common point
   * Table meeting
   * Organizing tasks
   * TODO:
      * Move !SelectManager->update() to a better location (!TestApp::update() to...?)
      * Add timing measures for performance
         * For !SelectManager::update()
         * For draw()
      * Research drag manager implementation
      * Improve code for !SelectManager
===Tues 10/23/07===
   * Removing HOVER_MOVE events
   * Investigating multiple HOVER_INs and HOVER_OUTs for single !TableInput events (there should only be one HOVER_OUT and one HOVER_IN)
===Mon 10/22/07===
   * Problem: Lag, with multiple !UserInputs it gets bogged down figuring out which objects are hovered/not hovered
      * Possible fix: Take out the HOVER_MOVE event since I can't think of any possible uses
      * Review code; see if it can be optimized anywhere
   * Helped Ted with a manual for demos
      * Found rygar isn't working
      * Walked him through necessary steps for other demo apps
   * Problem: There seems to be way too many events being thrown by the test !TableInput ex. it'll send out 3 hover_in & hover_outs at a time
      * Need to look through code (already will be to optimize for above problem)
===Fri 10/19/07===
   * Initial attempt
      * Inserting BasicInput
         * TableInput, SDLMouseInput now subclass BasicInput
         * Data (x,y,pressed,quit) and methods moved to BasicInput
      * Creating InputManager
         * Since UserInput and InputManager are now differentiated, UserInput subclasses can use isQuit() and update() (instead of getQuit() and run_update())
      * %X% Compile was unsuccessful, didn't manage changes well enough - went back to previous code
   * Attempt #2
      * Creating InputManager
         * %Y% Initially in addition to UserInput
         * %Y% Change UserInput subclasses to register with InputManager additionally
         * %Y% Switch the application from using UserInput to InputManager
      * Modifying UserInput
         * %Y% Remove references to static vars from subclasses
         * %Y% Remove static vars & methods (that are now in InputManager)
         * %Y% Changing virtual functions back getQuit()->isQuit(), run_update()->update()
         * %Y% Added {UI_type,UI_data,getType(),getDataFormat()} and the static vars {MOUSE_INPUT,TABLE_INPUT,BASIC_DATA,GESTURE_DATA,REALTIME_DATA}
      * Modifying TableInput for multiple instances (one per user)
         * %Y% Removed static vars & methods {isCreated, inst, instance()} except createInstance()
         * %Y% Expanded createInstance()->createInstance(uid)
      * Inserting BasicInput
         * %Y% Subclass UserInput with BasicInput
         * %Y% Move SDLMouseInput and TableInput from under UserInput to under BasicInput
      * Fixing SelectManager for multiple inputs gracefully
         * Added init() function which fills in a map of UserInput* -> Input* for last inputs of each UserInput
         * Modified update() function to use the <UserInput,Input> map to retrieve and update the correct last_ui
         * Added map<UserInput*,set<UIComponent*> > for hovered objects for each UserInput
            * Tried implementing really quick - seg fault (I forgot to initialize the map's stuff in init() - TODO)
   * TODO:
      * Make UserInput(/InputManager now) handle multiple inputs
         * %Y% Insert BasicInput between UserInput and {SDLMouseInput,TableInput}
         * Fix SelectManager for multiple inputs (handle things and extra data gracefully)
         * %Y% One UserInput per user for TableInput (singleton->not singleton)
         * %Y% Create InputManager to keep track of inputs (rather than in UserInput)

===Thurs 10/18/07===
   * Modifying !UserInputs
      * Changed virtual bool !UserInput::update() to static bool !UserInput::update() and added virtual bool !UserInput::run_update()
      * In the subclasses <class>::update() was changed to <class>::run_update()
   * Modifying !SelectManager
      * Need to !SelectManager::update() for each !UserInput -> added a little temporary struct for handling data, "Input"
      * Added !SelectManager::last_m,last_t which are Input (so update() doesn't confuse the last A from the last B)
   * Oy. Just realized we'll need last for EVERY user on the table since we don't want them to interfere with each other
      * Already knew we'd need to make a dynamic # of last (for different #s of inputs) but I didn't even think about multiple users
      * Mapping out exactly what we'll want to interact as far as hovering is concerned and additional data that'll be needed
         * uid // user id data attached to events
         * !UserInputs are processed one at a time, mouse input shouldn't affect table input
         * Within table inputs, at least for the old architecture, ~~we won't even want different fids interacting~~ no fids, only hover on hands
   * TODO:
      * Make !UserInput handle multiple inputs
         * Find out what additional info is gonna need to be stored (I'm worried it may be a lot... sets of !UIComponent pointers for each fid)
      * Insert !BasicInput between !UserInput and {!SDLMouseInput,!TableInput}
      * Fix !SelectManager for multiple inputs (handle things and extra data gracefully)
      * One !UserInput per user for !TableInput (singleton->not singleton)
      * Create !UserInputManager to keep track of inputs (rather than in !UserInput)
===Wed 10/17/07===
   * Removed select from !SDLMouseInput and !TableInput
   * Modified !SelectManager::update() to interpret "selects" (clicks)
   * Realized for HOVER_IN, HOVER_OUT and HOVER_MOVE we'll want to send it to ALL objects at a point, not just the top object
      * Modifying obj -> objs in !SelectManager
   * Got all the events working
      * Realized it wasn't processing them in with the proper order -> doesn't go through registeredHandlers just handles the events itself
      * FIX: create !UIComponent::processEvent(Event) which will check the registeredHandlers
   * Added Shape::setFillColor(r,g,b) and Shape::setStrokeColor(r,g,b)
   * Added Shape::getFillColor(r,g,b) and Shape::getStrokeColor(r,g,b)
   * %X% Removed userInput member of !TenMilManUI replacing it with static functions of !UserInput
      * Changed !UserInput::isQuit() from a pure virtual function to a static function that returns true if ANY of the !UserInputs returns true isQuit() and false otherwise
      * Changed !UserInput::update() from a pure virtual function to a static function that returns false if there aren't any !UserInputs instantiated, otherwise it updates all !UserInputs and returns true
   * Added userInput member back in after failing testing
   * !TableProject Meeting
   * Attempting to allow for multiple !UserInputs again...
      * Started out slow - remove userInput
      * Replace !ITenMilManUI::getUserInput() with !ITenMilManUI::initializeUserInput()
         * New function is void and simply instantiates the !UserInputs w/o returning their values, implemented in !TMMUI_TestApp.h
         * In !TenMilManUI::TenMilManUI(app) run initializeUserInput() rather than getUserInput()
      * In !TenMilManUI::run()
         * Replace userInput->{update(),isQuit()} with !SDLMouseInput::instance()->{update(),isQuit()} (since !SDLMouseInput is the only way to quit currently)
         * %X% Problem? How will !TableInput be processed? If !TableInput->update() pops an event off a queue of events we'll have problems; can't run !TableInput->update() in !TenMilManUI::run() AND !SelectManager->update()
            * Peter said !SelectManager shouldn't be updating the !UserInput, it should just assume !TenMilManUI::run() has updated it already
         * %X% New problem? If !TenMilManUI::run() updates !UserInput from the table (popping off events from it) what if run() runs faster than !SelectManager::update() lost events?
            * Possible fix: Put in a queue somewhere for !TableInput::update() to shove events onto so !SelectManager can handle them in it's own sweet time
      * %Y% So far so good...
         * Changed virtual bool isQuit() to static bool isQuit() which checks it's inputs for for isQuit()
            * Feared there might be a problem since inputs have isQuit() and !UserInput has isQuit(), but no errors given
            * %X% The app crashed just like when I made the changes previously
               * I found the problem was in !UserInput::isQuit()
               * Since the subclasses had isQuit() but !UserInput also had a static isQuit() it crashed
               * %Y% FIXED: Renamed subclass isQuit() to getQuit() (less intuitive) and added virtual bool getQuit() to !UserInput
      * Now checks both inputs for "quit" - w00t
      * Still need to clean-up !TenMilManUI::run() but the worst of it is over
      * NOTE: I'll need to do the same thing I did for isQuit/getQuit for update()

   * TODO:
      * %Y% Remove select from !SDLMouseInput, implement in !SelectManager instead
      * %Y% Add HOVER_IN, HOVER_OUT and HOVER_MOVE to the events that are detected and dispatched
      * Make !UserInput handle multiple inputs
===Tues 10/16/07===
   * Created !InteractiveRectangle which subclasses !UIComponent
      * Hopefully this will allow me to create and test event handler code
      * Test program doesn't run, although it does compile successfully
   * Made !UIComponent a subclass of !EventHandler
      * This will handle the basic events that all basic controls will have
      * Changed !EventHandler::getObjectID() to !EventHandler::getEvtHandlerID() because there was ambiguity
   * Added names for events to !UIComponent
      * In !UIComponent.h
         * static std::string ~event name~
      * In !UIComponent.cpp
         * std::string !UIComponent::~event name~ = "~event name~";
   * Got the !SelectManager working as desired, but object info is incorrect -> !GetW() and !GetH() are returning 10
      * Tracked the problem down to the !DisplayObject class
         * !DisplayObject constructor sets w and h to 10, always
         * FIX: Went higher up to the first class that specified w & h in the constructor, !DisplayObjectContainer - specified that it use the w & h arguments to actually set the values
   * Modified !SelectManager
      * Added the ability to dispatch multiple events { UNPRESS == CLICK, so dispatch both }
      * Modified PRESS events so only "detected" if the last event wasn't a press
   * Created test class "!InteractiveRectangle" for testing event handlers
      * Successfully tested PRESS, UNPRESS and CLICK events
   * TODO:
      * Remove select from !SDLMouseInput, implement in !SelectManager instead
      * Add HOVER_IN, HOVER_OUT and HOVER_MOVE to the events that are detected and dispatched

===Mon 10/15/07===
   * Working on understanding !EventHandlers
      * !SelectManager registers UIComponents; unfortunately, all the things that can be displayed (currently) aren't derived from UIComponent
      * I'll talk with Peter about it more later, instead of implementing handleEvent (since I can't easily test it, I'll work on !SelectManager::update() to encompass more events besides selection)
   * !SelectManager::update()
      * Added logic to also handle "PRESS" events (!OnMouseDown equivalent)
      * Added map<int,UIComponent>pressedObjects to keep track of pressed objects as well
      * TODO: Add logic to add/remove items from the selected(&pressed) objects maps
   * objs -> obj in SelectManager
      * Modified so instead of a stack of objects, only one is checked the "top" graphically
      * NOTE: The "top" graphically depends on the order the objects are registered to the SelectManager, it's assumed that they'll be registered on instantiation.
   * After making the objs->obj change in SelectManager, I tried to run the test app - it doesn't appear to run anymore...
   * TODO:
      * objs -> obj in !SelectManager
      * Modify for dispatching multiple events in !SelectManager
      * Create a test class for testing !EventHandler
===Fri 10/12/07===
   * Modifying !UserInput
      * Make multiple instantiation of !UserInput possible (remove singleton-ness)
         * Change w/o making it incompatible with current test program
         * !UserInput now contains set<!UserInput> inputs which keeps track of all !UserInputs
         * isCreated and inst variables from !UserInput will now be part of the subclasses, since they'll be singletons
         * getX() and all accessor functions are now implemented in the subclasses, but they'll need to be specified in the !UserInput class
         * !UserInput::instance() now retrieves the first !UserInput in the set !UserInput::inputs
         * !SDLMouseInput::createInstance() handles !SDLMouseInput static vars and adds itself to !UserInput::inputs
      * Finished moving info from !InputData to !UserInput subclasses
   * Modifying !SelectManager
      * Update !SelectManager::update() to deal with modified !UserInput class
      * !SelectManager::update() now works with modified !UserInput class, but there'll be problems with advanced behavior (only checks a couple things for equivalence right now) as it is
         * Checks for equivalent events via x,y,pressed & select -> what will happen for special table events?
   * Create !TableInput : !UserInput
      * Made basic setup for getting events from the table
      * Forgot that quitting was done through !UserInput, without !TableInput having a "quit" you can't quit; had to kill from pitfall
===Wed 10/10/07===
   * Subclassed !InputData class in !UserInput.cpp, original !InputClass should be sufficient for the mouse
      * !InputData
         *    ADDED side_id
      * !GestureData
         * INHERITS x,y (starting point)
         *    ADDED gestureStr (string containing the sequence of the gesture ex. "LDUR")
      * !RealTimeData
         * INHERITS x,y {starting point, center point} (depending on event type)
         *    ADDED evtType { "DRAG", "ROTATE", "ZOOM" }
         *    ADDED amt     {   dist,    angle,  scale }
   * Modified !UserInput
      * ADDED getSide()
      * ADDED getClass() { MOUSE, GESTURE, REALTIME }
   * Event class will need the same info as !InputData, do we need a new class?
      * #define Event !InputData%BR%
        #define !GestureEvent !GestureData%BR%
        #define !RealTimeEvent !RealTimeData
   * Work on !SelectManager
      * Updated !SelectManager::update() to get input from !UserInput and check if it's repeated input
      * Processes select event to objects at (x,y)
   * Moved select from !InteractiveObject to UIComponent
   * Worked on implementing !EventHandler::process(Event evt)
      * Successfully added to component and called on select
      * Problem: Event doesn't contain a target object, should add that
      * Talked to Peter, apparently, controls are going to be subclasses of !EventHandlers as well
         * With this setup, what should !EventHandlers be registered with the !UIComponent since the UIComponent is an !EventHandler?
   * Removed !InputData, !GestureData and !RealTimeData classes
      * Will need to re-work how data is Xfered then
   * TODO:
      * Implement !EventHandler::process(Event evt)
===Mon 10/8/07===
   * Moved classes to TenUI namespace
      * Managers
      * Event, !EventHandler, !EventDispatcher
   * Removed !InteractiveObject
   * Discussed new structure of !InputData with Thomas
      * Decided to subclass into !RealTimeData, !GestureData, !MouseData(?)
   * TODO:
      * Implement !EventHandler::process(Event evt)
      * Update !UserInput to deal with data for new architecture
      * Update Event to handle necessary data
      * Talk to Peter about necessity of !DragManager

===Fri 10/5/07===
   * Working on manager related stuff
      * Modified definition so managers now deal with !UIComponents instead of !InteractiveObjects
      * Implementing !SelectManager::update function
         * Checks for chg in !UserInput
         * If chg = select => package
         * Get objects that are at pt (x,y)
         * See which if any are registered with the manager
         * If registered, tell them to process the event
      * Implementing !InteractiveObject::select(Event evt) function
         * Takes event, get event handlers for evt->evtName
         * Process all event handlers for evtName
      * Made !DisplayObject a subclass of !EventDispatcher
   * TODO:
      * Implement !EventHandler::process(Event evt)
      * Update !UserInput to deal with data for new architecture
      * Update Event to handle necessary data