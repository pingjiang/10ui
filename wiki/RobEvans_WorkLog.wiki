#summary Rob Evans' Work Log
==Work log==
This is the work log of Rob Evans, that is all.
===Tues 10/16/07===
   * Created !InteractiveRectangle which subclasses !UIComponent
      * Hopefully this will allow me to create and test event handler code
      * Test program doesn't run, although it does compile successfully
   * Made !UIComponent a subclass of !EventHandler
      * This will handle the basic events that all basic controls will have
      * Changed !EventHandler::getObjectID() to !EventHandler::getEvtHandlerID() because there was ambiguity
   * Added names for events to !UIComponent
      * In !UIComponent.h
         * static std::string ~event name~
      * In !UIComponent.cpp
         * std::string !UIComponent::~event name~ = "~event name~";
   * Got the !SelectManager working as desired, but object info is incorrect -> !GetW() and !GetH() are returning 10
      * Tracked the problem down to the !DisplayObject class
         * !DisplayObject constructor sets w and h to 10, always
         * FIX: Went higher up to the first class that specified w & h in the constructor, !DisplayObjectContainer - specified that it use the w & h arguments to actually set the values
   * Modified !SelectManager
      * Added the ability to dispatch multiple events { UNPRESS == CLICK, so dispatch both }
      * Modified PRESS events so only "detected" if the last event wasn't a press
   * Created test class "!InteractiveRectangle" for testing event handlers
      * Successfully tested PRESS, UNPRESS and CLICK events
   * TODO:
      * Remove select from !SDLMouseInput, implement in !SelectManager instead
      * Add HOVER_IN, HOVER_OUT and HOVER_MOVE to the events that are detected and dispatched

===Mon 10/15/07===
   * Working on understanding !EventHandlers
      * !SelectManager registers UIComponents; unfortunately, all the things that can be displayed (currently) aren't derived from UIComponent
      * I'll talk with Peter about it more later, instead of implementing handleEvent (since I can't easily test it, I'll work on !SelectManager::update() to encompass more events besides selection)
   * !SelectManager::update()
      * Added logic to also handle "PRESS" events (!OnMouseDown equivalent)
      * Added map<int,UIComponent>pressedObjects to keep track of pressed objects as well
      * TODO: Add logic to add/remove items from the selected(&pressed) objects maps
   * objs -> obj in SelectManager
      * Modified so instead of a stack of objects, only one is checked the "top" graphically
      * NOTE: The "top" graphically depends on the order the objects are registered to the SelectManager, it's assumed that they'll be registered on instantiation.
   * After making the objs->obj change in SelectManager, I tried to run the test app - it doesn't appear to run anymore...
   * TODO:
      * objs -> obj in !SelectManager
      * Modify for dispatching multiple events in !SelectManager
      * Create a test class for testing !EventHandler
===Fri 10/12/07===
   * Modifying !UserInput
      * Make multiple instantiation of !UserInput possible (remove singleton-ness)
         * Change w/o making it incompatible with current test program
         * !UserInput now contains set<!UserInput> inputs which keeps track of all !UserInputs
         * isCreated and inst variables from !UserInput will now be part of the subclasses, since they'll be singletons
         * getX() and all accessor functions are now implemented in the subclasses, but they'll need to be specified in the !UserInput class
         * !UserInput::instance() now retrieves the first !UserInput in the set !UserInput::inputs
         * !SDLMouseInput::createInstance() handles !SDLMouseInput static vars and adds itself to !UserInput::inputs
      * Finished moving info from !InputData to !UserInput subclasses
   * Modifying !SelectManager
      * Update !SelectManager::update() to deal with modified !UserInput class
      * !SelectManager::update() now works with modified !UserInput class, but there'll be problems with advanced behavior (only checks a couple things for equivalence right now) as it is
         * Checks for equivalent events via x,y,pressed & select -> what will happen for special table events?
   * Create !TableInput : !UserInput
      * Made basic setup for getting events from the table
      * Forgot that quitting was done through !UserInput, without !TableInput having a "quit" you can't quit; had to kill from pitfall
===Wed 10/10/07===
   * Subclassed !InputData class in !UserInput.cpp, original !InputClass should be sufficient for the mouse
      * !InputData
         *    ADDED side_id
      * !GestureData
         * INHERITS x,y (starting point)
         *    ADDED gestureStr (string containing the sequence of the gesture ex. "LDUR")
      * !RealTimeData
         * INHERITS x,y {starting point, center point} (depending on event type)
         *    ADDED evtType { "DRAG", "ROTATE", "ZOOM" }
         *    ADDED amt     {   dist,    angle,  scale }
   * Modified !UserInput
      * ADDED getSide()
      * ADDED getClass() { MOUSE, GESTURE, REALTIME }
   * Event class will need the same info as !InputData, do we need a new class?
      * #define Event !InputData%BR%
        #define !GestureEvent !GestureData%BR%
        #define !RealTimeEvent !RealTimeData
   * Work on !SelectManager
      * Updated !SelectManager::update() to get input from !UserInput and check if it's repeated input
      * Processes select event to objects at (x,y)
   * Moved select from !InteractiveObject to UIComponent
   * Worked on implementing !EventHandler::process(Event evt)
      * Successfully added to component and called on select
      * Problem: Event doesn't contain a target object, should add that
      * Talked to Peter, apparently, controls are going to be subclasses of !EventHandlers as well
         * With this setup, what should !EventHandlers be registered with the !UIComponent since the UIComponent is an !EventHandler?
   * Removed !InputData, !GestureData and !RealTimeData classes
      * Will need to re-work how data is Xfered then
   * TODO:
      * Implement !EventHandler::process(Event evt)
===Mon 10/8/07===
   * Moved classes to TenUI namespace
      * Managers
      * Event, !EventHandler, !EventDispatcher
   * Removed !InteractiveObject
   * Discussed new structure of !InputData with Thomas
      * Decided to subclass into !RealTimeData, !GestureData, !MouseData(?)
   * TODO:
      * Implement !EventHandler::process(Event evt)
      * Update !UserInput to deal with data for new architecture
      * Update Event to handle necessary data
      * Talk to Peter about necessity of !DragManager

===Fri 10/5/07===
   * Working on manager related stuff
      * Modified definition so managers now deal with !UIComponents instead of !InteractiveObjects
      * Implementing !SelectManager::update function
         * Checks for chg in !UserInput
         * If chg = select => package
         * Get objects that are at pt (x,y)
         * See which if any are registered with the manager
         * If registered, tell them to process the event
      * Implementing !InteractiveObject::select(Event evt) function
         * Takes event, get event handlers for evt->evtName
         * Process all event handlers for evtName
      * Made !DisplayObject a subclass of !EventDispatcher
   * TODO:
      * Implement !EventHandler::process(Event evt)
      * Update !UserInput to deal with data for new architecture
      * Update Event to handle necessary data