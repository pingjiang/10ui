#summary Rob Evans' Work Log
==Work log==
This is the work log of Rob Evans, that is all.
===Fri 10/12/07===
   * Modifying !UserInput
      * Make multiple instantiation of !UserInput possible (remove singleton-ness)
         * Change w/o making it incompatible with current test program
         * !UserInput now contains set<!UserInput> inputs which keeps track of all !UserInputs
         * isCreated and inst variables from !UserInput will now be part of the subclasses, since they'll be singletons
         * getX() and all accessor functions are now implemented in the subclasses, but they'll need to be specified in the !UserInput class
         * !UserInput::instance() now retrieves the first !UserInput in the set !UserInput::inputs
         * !SDLMouseInput::createInstance() handles !SDLMouseInput static vars and adds itself to !UserInput::inputs
      * Finished moving info from !InputData to !UserInput subclasses
   * Modifying !SelectManager
      * Update !SelectManager::update() to deal with modified !UserInput class
      * !SelectManager::update() now works with modified !UserInput class, but there'll be problems with advanced behavior (only checks a couple things for equivalence right now) as it is
         * Checks for equivalent events via x,y,pressed & select -> what will happen for special table events?
   * Create !TableInput : !UserInput
      * Made basic setup for getting events from the table
      * Forgot that quitting was done through !UserInput, without !TableInput having a "quit" you can't quit; had to kill from pitfall
===Wed 10/10/07===
   * Subclassed !InputData class in !UserInput.cpp, original !InputClass should be sufficient for the mouse
      * !InputData
         *    ADDED side_id
      * !GestureData
         * INHERITS x,y (starting point)
         *    ADDED gestureStr (string containing the sequence of the gesture ex. "LDUR")
      * !RealTimeData
         * INHERITS x,y {starting point, center point} (depending on event type)
         *    ADDED evtType { "DRAG", "ROTATE", "ZOOM" }
         *    ADDED amt     {   dist,    angle,  scale }
   * Modified !UserInput
      * ADDED getSide()
      * ADDED getClass() { MOUSE, GESTURE, REALTIME }
   * Event class will need the same info as !InputData, do we need a new class?
      * #define Event !InputData%BR%
        #define !GestureEvent !GestureData%BR%
        #define !RealTimeEvent !RealTimeData
   * Work on !SelectManager
      * Updated !SelectManager::update() to get input from !UserInput and check if it's repeated input
      * Processes select event to objects at (x,y)
   * Moved select from !InteractiveObject to UIComponent
   * Worked on implementing !EventHandler::process(Event evt)
      * Successfully added to component and called on select
      * Problem: Event doesn't contain a target object, should add that
      * Talked to Peter, apparently, controls are going to be subclasses of !EventHandlers as well
         * With this setup, what should !EventHandlers be registered with the !UIComponent since the UIComponent is an !EventHandler?
   * Removed !InputData, !GestureData and !RealTimeData classes
      * Will need to re-work how data is Xfered then
   * TODO:
      * Implement !EventHandler::process(Event evt)
===Mon 10/8/07===
   * Moved classes to TenUI namespace
      * Managers
      * Event, !EventHandler, !EventDispatcher
   * Removed !InteractiveObject
   * Discussed new structure of !InputData with Thomas
      * Decided to subclass into !RealTimeData, !GestureData, !MouseData(?)
   * TODO:
      * Implement !EventHandler::process(Event evt)
      * Update !UserInput to deal with data for new architecture
      * Update Event to handle necessary data
      * Talk to Peter about necessity of !DragManager

===Fri 10/5/07===
   * Working on manager related stuff
      * Modified definition so managers now deal with !UIComponents instead of !InteractiveObjects
      * Implementing !SelectManager::update function
         * Checks for chg in !UserInput
         * If chg = select => package
         * Get objects that are at pt (x,y)
         * See which if any are registered with the manager
         * If registered, tell them to process the event
      * Implementing !InteractiveObject::select(Event evt) function
         * Takes event, get event handlers for evt->evtName
         * Process all event handlers for evtName
      * Made !DisplayObject a subclass of !EventDispatcher
   * TODO:
      * Implement !EventHandler::process(Event evt)
      * Update !UserInput to deal with data for new architecture
      * Update Event to handle necessary data